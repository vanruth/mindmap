<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mindmap Builder</title>
    <!-- Google Fonts: Inter -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <style>
        /* CSS Variables - Adhering to the design brief */
        :root {
            --bg: #fafafa;
            --card: #ffffff;
            --border: #e5e7eb;
            --border-hover: #d4d4d8;
            --text: #1f2937;
            --text-muted: #6b7280;
            --hover-bg: #f5f5f5;
            --connection: #e5e7eb;
            --shadow-subtle: 0 1px 3px rgba(0,0,0,0.05);
            --shadow-medium: 0 4px 12px rgba(0,0,0,0.08);
            --shadow-large: 0 4px 16px rgba(0,0,0,0.1);
            --danger: #ef4444; /* red-500 */
        }

        /* Base & Typography */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', sans-serif;
        }
        body {
            background: var(--bg);
            overflow: hidden;
            height: 100vh;
            color: var(--text);
        }

        /* Canvas */
        #canvas {
            width: 100%;
            height: 100vh;
            position: relative;
            cursor: grab;
        }
        #canvas.grabbing {
            cursor: grabbing;
        }
        #connections {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
        }
        .connection {
            stroke: var(--connection);
            stroke-width: 2;
            fill: none;
        }

        /* Node Styles */
        .node {
            position: absolute;
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px 16px;
            min-width: 80px;
            box-shadow: var(--shadow-subtle);
            transition: all 0.15s ease;
            cursor: move;
            z-index: 10;
            user-select: none;
        }
        .node:hover {
            box-shadow: var(--shadow-medium);
            border-color: var(--border-hover);
        }
        .node.dragging {
            opacity: 0.8;
            z-index: 1000;
        }

        /* Text Content */
        .node-text {
            outline: none;
            border: none;
            background: transparent;
            font-size: 14px;
            font-weight: 500;
            color: var(--text);
            width: 100%;
            text-align: center;
            cursor: text;
            /* Initially constrain width */
            max-width: 100%;
        }

        /* Node Actions */
        .node-actions {
            position: absolute;
            top: -24px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 4px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.1s;
        }
        .node:hover .node-actions {
            opacity: 1;
            pointer-events: all;
        }
        .action-button {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: 1px solid var(--border);
            background: var(--card);
            color: var(--text-muted);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: var(--shadow-subtle);
            transition: background 0.1s, color 0.1s;
        }
        .action-button:hover {
            background: var(--hover-bg);
            color: var(--text);
        }
        .action-button.delete-btn {
            color: var(--danger);
            position: absolute;
            top: 0;
            right: -32px;
        }
        .action-button.delete-btn:hover {
            background: #fecaca; /* red-200 */
        }

        /* Resize Handle */
        .resize-handle {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 12px;
            height: 12px;
            cursor: nwse-resize;
            background: transparent; /* transparent for interaction, but invisible */
            z-index: 20;
        }

        /* Toolbar */
        #toolbar {
            position: fixed;
            top: 16px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            background: rgba(255,255,255,0.9);
            backdrop-filter: blur(8px);
            padding: 8px 12px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
            opacity: 0.2;
            transition: opacity 0.2s;
            z-index: 100;
        }
        #toolbar:hover {
            opacity: 1;
        }
        #toolbar input {
            padding: 6px 10px;
            border: 1px solid var(--border);
            border-radius: 6px;
            width: 160px;
            font-size: 13px;
            font-weight: 400;
            color: var(--text);
            background: var(--card);
            outline: none;
            transition: border-color 0.15s;
        }
        #toolbar input:focus {
            border-color: var(--text-muted);
        }
        #toolbar button {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            padding: 0;
            border: 1px solid var(--border);
            border-radius: 6px;
            background: var(--card);
            cursor: pointer;
            color: var(--text-muted);
            transition: background 0.1s, border-color 0.1s, color 0.1s;
        }
        #toolbar button:hover {
            background: var(--hover-bg);
            border-color: var(--border-hover);
            color: var(--text);
        }
        #toolbar button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        /* Gallery */
        #gallery {
            position: fixed;
            right: 16px;
            top: 80px;
            width: 280px;
            max-height: calc(100vh - 100px);
            background: var(--card);
            border-radius: 8px;
            box-shadow: var(--shadow-large);
            overflow: auto;
            z-index: 99;
            display: none;
            padding: 12px;
            border: 1px solid var(--border);
        }
        .gallery-header {
            font-size: 14px;
            font-weight: 600;
            color: var(--text);
            margin-bottom: 12px;
            padding: 4px 0;
            border-bottom: 1px solid var(--border);
        }
        .gallery-item {
            display: flex;
            align-items: center;
            padding: 8px 10px;
            border-radius: 6px;
            margin-bottom: 6px;
            cursor: pointer;
            transition: background 0.1s;
            border: 1px solid transparent;
        }
        .gallery-item:hover {
            background: var(--hover-bg);
            border-color: var(--border);
        }
        .item-info {
            flex-grow: 1;
            padding-left: 8px;
        }
        .item-title {
            font-size: 14px;
            font-weight: 500;
            color: var(--text);
        }
        .item-date {
            font-size: 11px;
            color: var(--text-muted);
        }
        .item-action-btn {
            background: none;
            border: none;
            cursor: pointer;
            color: var(--text-muted);
            padding: 0 4px;
            transition: color 0.1s;
        }
        .item-action-btn:hover {
            color: var(--text);
        }
        .item-action-btn.delete:hover {
            color: var(--danger);
        }
        /* Split Save Button */
.save-group {
    display: flex;
    position: relative;
}

#save-main-btn {
    border-top-right-radius: 0;
    border-bottom-right-radius: 0;
}

#save-dropdown-btn {
    width: 32px;
    height: 32px;
    border-left: none;
    border-top-left-radius: 0;
    border-bottom-left-radius: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
}

#save-dropdown-menu {
    position: absolute;
    top: 38px;
    right: 0;
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 6px;
    box-shadow: var(--shadow-large);
    display: none;
    flex-direction: column;
    width: 140px;
    z-index: 200;
}

.save-dropdown-item {
    padding: 8px 12px;
    cursor: pointer;
    font-size: 13px;
    color: var(--text);
}

.save-dropdown-item:hover {
    background: var(--hover-bg);
}

/* Delete X only on hover */
.action-button.delete-btn {
    opacity: 0;
    transition: opacity 0.15s;
}

.node:hover .delete-btn {
    opacity: 1;
}


        /* Modal/Dialog */
        #modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        .modal-content {
            background: var(--card);
            padding: 24px;
            border-radius: 12px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
            width: 90%;
            max-width: 400px;
        }
        .modal-message {
            font-size: 15px;
            font-weight: 500;
            margin-bottom: 16px;
            color: var(--text);
        }
        .modal-input {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--border);
            border-radius: 6px;
            font-size: 14px;
            margin-bottom: 20px;
            color: var(--text);
        }
        .modal-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }
        .modal-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.1s, opacity 0.1s;
        }
        .modal-btn.cancel {
            background: none;
            color: var(--text-muted);
        }
        .modal-btn.cancel:hover {
            background: var(--hover-bg);
            color: var(--text);
        }
        .modal-btn.confirm {
            background: var(--text);
            color: var(--card);
        }
        .modal-btn.confirm:hover {
            background: #4b5563; /* neutral-700 */
        }
        .modal-btn.ok {
             background: var(--text);
            color: var(--card);
        }
        .modal-btn.ok:hover {
            background: #4b5563;
        }

        /* Link Display Modal specific styles */
        #link-display {
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
            font-size: 12px;
            background: var(--hover-bg);
            border: 1px solid var(--border);
            padding: 8px;
            border-radius: 4px;
            word-break: break-all;
            color: var(--text-muted);
        }
    </style>
</head>
<body>

    <div id="canvas">
        <svg id="connections"></svg>
        <!-- Dynamic nodes will be appended here -->
    </div>

    <div id="toolbar">
        <input id="map-title" type="text" placeholder="Untitled">
        <button id="undo-btn" title="Undo"><i data-lucide="undo-2"></i></button>
        <button id="redo-btn" title="Redo"><i data-lucide="redo-2"></i></button>
        <div class="save-group">
    <button id="save-main-btn" title="Save"><i data-lucide="save"></i></button>
    <button id="save-dropdown-btn" title="More Save Options"><i data-lucide="chevron-down"></i></button>

    <div id="save-dropdown-menu">
        <div class="save-dropdown-item" id="save-as-menu-item">Save Asâ€¦</div>
    </div>
</div>

<button id="new-btn" title="New Map"><i data-lucide="file-plus"></i></button>

        <button id="gallery-btn" title="Open Gallery"><i data-lucide="folder-open"></i></button>
    </div>

    <div id="gallery">
        <div class="gallery-header">Saved Maps</div>
        <div id="gallery-list">
            <!-- Saved maps list items appended here -->
        </div>
    </div>

    <!-- Universal Modal for Alerts, Prompts, and Links -->
    <div id="modal">
        <div class="modal-content">
            <div id="modal-message" class="modal-message"></div>
            <input type="text" id="modal-input" class="modal-input" style="display: none;">
            <div id="link-display-container" style="display: none;">
                <div id="link-display"></div>
            </div>
            <div class="modal-buttons">
                <button id="modal-cancel" class="modal-btn cancel" style="display: none;">Cancel</button>
                <button id="modal-confirm" class="modal-btn confirm" style="display: none;">Confirm</button>
                <button id="modal-ok" class="modal-btn ok" style="display: none;">OK</button>
            </div>
        </div>
    </div>

<script>
    // --- Global State and Constants ---
    const APP_BASE_URL = 'https://mindmap-puce.vercel.app';    const LOCAL_STORAGE_KEY = 'mindmap-data';
    const canvas = document.getElementById('canvas');
    const connectionsSvg = document.getElementById('connections');
    const mapTitleInput = document.getElementById('map-title');
    const gallery = document.getElementById('gallery');
    const galleryList = document.getElementById('gallery-list');

    // Modal elements
    const modal = document.getElementById('modal');
    const modalMessage = document.getElementById('modal-message');
    const modalInput = document.getElementById('modal-input');
    const modalCancel = document.getElementById('modal-cancel');
    const modalConfirm = document.getElementById('modal-confirm');
    const modalOK = document.getElementById('modal-ok');
    const linkDisplayContainer = document.getElementById('link-display-container');
    const linkDisplay = document.getElementById('link-display');

    // History and State
    let nodes = [];
    let history = [];
    let historyIndex = -1;
    let currentMapIndex = null;
    let originalTitle = '';

    let draggingNode = null;
    let resizingNode = null;
    let panState = { isPanning: false, startX: 0, startY: 0 };
    let resizeStart = { x: 0, y: 0, width: 0, height: 0 };

    // --- Utility Functions (Modal) ---

    // Shows a simple alert dialog
    function showAlert(message) {
        return new Promise(resolve => {
            modalMessage.textContent = message;
            modalInput.style.display = 'none';
            linkDisplayContainer.style.display = 'none';

            modalCancel.style.display = 'none';
            modalConfirm.style.display = 'none';
            modalOK.style.display = 'inline-block';

            const handler = () => {
                modalOK.removeEventListener('click', handler);
                modal.style.display = 'none';
                resolve();
            };
            modalOK.addEventListener('click', handler);
            modal.style.display = 'flex';
        });
    }

    // Shows a prompt dialog and returns the input value or null on cancel
    function showPrompt(message, defaultValue = '') {
        return new Promise(resolve => {
            modalMessage.textContent = message;
            modalInput.value = defaultValue;
            modalInput.style.display = 'block';
            linkDisplayContainer.style.display = 'none';

            modalCancel.style.display = 'inline-block';
            modalConfirm.style.display = 'inline-block';
            modalOK.style.display = 'none';

            const handleConfirm = () => {
                removeHandlers();
                modal.style.display = 'none';
                resolve(modalInput.value);
            };
            const handleCancel = () => {
                removeHandlers();
                modal.style.display = 'none';
                resolve(null);
            };
            const removeHandlers = () => {
                modalConfirm.removeEventListener('click', handleConfirm);
                modalCancel.removeEventListener('click', handleCancel);
            };

            modalConfirm.addEventListener('click', handleConfirm);
            modalCancel.addEventListener('click', handleCancel);
            modal.style.display = 'flex';
            modalInput.focus();
            modalInput.select();
        });
    }

    // Shows a link display dialog
    function showLink(message, link) {
        return new Promise(resolve => {
            modalMessage.textContent = message;
            linkDisplay.textContent = link;
            linkDisplayContainer.style.display = 'block';
            modalInput.style.display = 'none';

            modalCancel.style.display = 'none';
            modalConfirm.style.display = 'none';
            modalOK.style.display = 'inline-block';

            const handler = () => {
                modalOK.removeEventListener('click', handler);
                modal.style.display = 'none';
                resolve();
            };
            modalOK.addEventListener('click', handler);
            modal.style.display = 'flex';
        });
    }

    // --- History Management ---

    // Captures the current state and pushes it to history
    function captureState() {
        const state = {
            nodes: nodes.map(n => ({
                id: n.id,
                parentId: n.parentId,
                text: n.el.querySelector('.node-text').textContent,
                x: parseFloat(n.el.style.left),
                y: parseFloat(n.el.style.top),
                width: n.el.offsetWidth,
                height: n.el.offsetHeight
            })),
            title: mapTitleInput.value
        };

        // Clear future history if we've moved back and are making a new change
        if (historyIndex < history.length - 1) {
            history = history.slice(0, historyIndex + 1);
        }

        history.push(JSON.parse(JSON.stringify(state)));

        // Limit history size
        if (history.length > 50) {
            history.shift();
        } else {
            historyIndex++;
        }
        updateHistoryButtons();
    }

    // Restores a state from history
    function restoreState(state) {
        clearCanvas();
        state.nodes.forEach(n => createNode(n.text, n.x, n.y, n.parentId, n.id, n.width, n.height, true));
        mapTitleInput.value = state.title;
        drawConnections();
        updateHistoryButtons();
    }

    function updateHistoryButtons() {
        document.getElementById('undo-btn').disabled = historyIndex <= 0;
        document.getElementById('redo-btn').disabled = historyIndex >= history.length - 1;
    }

    // --- Node Management ---

    // Clears all nodes from the canvas
    function clearCanvas() {
        nodes.forEach(n => n.el.remove());
        nodes = [];
        connectionsSvg.innerHTML = '';
    }

    // Finds a node object by its ID
    function findNodeById(id) {
        return nodes.find(n => n.id === id);
    }

    // Creates the DOM element for a node
    function createNode(text, x, y, parentId = null, id = null, w = null, h = null, skipCapture = false) {
        const nodeEl = document.createElement('div');
        nodeEl.className = 'node';
        nodeEl.style.left = x + 'px';
        nodeEl.style.top = y + 'px';

        id = id || 'n' + Date.now() + Math.random().toString(36).substring(2, 7);
        nodeEl.dataset.id = id;
        nodeEl.dataset.parentId = parentId || '';

        // Node structure
        const textEl = document.createElement('div');
        textEl.className = 'node-text';
        textEl.contentEditable = true;
        textEl.textContent = text;
        nodeEl.appendChild(textEl);

        // Actions container
        const actionsEl = document.createElement('div');
        actionsEl.className = 'node-actions';

        // Add Child Button
        const addChildBtn = document.createElement('button');
        addChildBtn.className = 'action-button';
        addChildBtn.innerHTML = '<i data-lucide="plus" style="width:16px; height:16px;"></i>';
        addChildBtn.title = 'Add Child Node';
        addChildBtn.onclick = (e) => {
            e.stopPropagation();
            addChildNode(id);
        };
        actionsEl.appendChild(addChildBtn);
        nodeEl.appendChild(actionsEl);

        // Delete Button (only for non-root nodes)
        if (parentId !== null) {
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'action-button delete-btn';
            deleteBtn.innerHTML = '<i data-lucide="x" style="width:16px; height:16px;"></i>';
            deleteBtn.title = 'Delete Node';
            deleteBtn.onclick = (e) => {
                e.stopPropagation();
                deleteNode(id);
            };
            nodeEl.appendChild(deleteBtn);
        }

        // Resize Handle (bottom-right corner)
        const resizeHandle = document.createElement('div');
        resizeHandle.className = 'resize-handle';
        resizeHandle.addEventListener('mousedown', (e) => {
            e.stopPropagation();
            startResize(e, nodeEl);
        });
        nodeEl.appendChild(resizeHandle);

        // Apply size if provided (from load/history)
        if (w) nodeEl.style.width = w + 'px';
        if (h) nodeEl.style.height = h + 'px';

        canvas.appendChild(nodeEl);
        nodes.push({ id, el: nodeEl, parentId });

        // Event listeners for dragging and content edit
        nodeEl.addEventListener('mousedown', (e) => {
            if (e.target.closest('.action-button') || e.target.closest('.resize-handle') || e.target === textEl) return;
            startDrag(e, nodeEl);
        });

        // Content editing capture state on blur
        textEl.addEventListener('input', () => {
            // Simple auto-resize logic (width only) if height isn't manually set
            if (!nodeEl.style.height || nodeEl.offsetHeight < 40) {
                const minWidth = 80;
                nodeEl.style.width = Math.max(minWidth, textEl.scrollWidth + 32) + 'px';
            }
            drawConnections();
        });
        textEl.addEventListener('blur', captureState);

        // Initial setup
        if (!w) {
             const minWidth = 80;
             nodeEl.style.width = Math.max(minWidth, textEl.scrollWidth + 32) + 'px';
        }

        drawConnections();
        lucide.createIcons(); // Initialize new icons
        if (!skipCapture) captureState();

        return id;
    }

    // Calculates position for a new child node
    function addChildNode(parentId) {
        const parent = findNodeById(parentId);
        if (!parent) return;

        const pRect = parent.el.getBoundingClientRect();
        const children = nodes.filter(n => n.parentId === parentId);
        const childCount = children.length;

        // Position children in a circle around the parent (or simple offset)
        const radius = 200;
        const angle = (Math.PI * 2 * childCount / 5) + (Math.random() * 0.4 - 0.2); // Spread out in an arc

        const newX = parseFloat(parent.el.style.left) + pRect.width / 2 + Math.cos(angle) * radius - 60; // -60 for node center
        const newY = parseFloat(parent.el.style.top) + pRect.height / 2 + Math.sin(angle) * radius - 30; // -30 for node center

        createNode('New Idea', newX, newY, parentId);
    }

    // Recursively deletes a node and all its descendants
    function deleteNode(id) {
        const nodeIndex = nodes.findIndex(n => n.id === id);
        if (nodeIndex === -1) return;

        // Delete children first (recursively)
        nodes.filter(n => n.parentId === id).forEach(child => deleteNode(child.id));

        // Delete self
        nodes[nodeIndex].el.remove();
        nodes.splice(nodeIndex, 1);

        drawConnections();
        captureState();
    }

    // --- Interaction Handlers ---

    // Drawing connections between nodes
    function drawConnections() {
        connectionsSvg.innerHTML = '';
        const viewportOffset = canvas.getBoundingClientRect();

        nodes.forEach(n => {
            if (!n.parentId) return;
            const parent = findNodeById(n.parentId);
            if (!parent) return;

            const nRect = n.el.getBoundingClientRect();
            const pRect = parent.el.getBoundingClientRect();

            // Calculate center points relative to the SVG/Canvas top-left
            const x1 = pRect.left + pRect.width / 2 - viewportOffset.left;
            const y1 = pRect.top + pRect.height / 2 - viewportOffset.top;
            const x2 = nRect.left + nRect.width / 2 - viewportOffset.left;
            const y2 = nRect.top + nRect.height / 2 - viewportOffset.top;

            // Simple line connection
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            // Using a simple smooth Bezier curve for a cleaner look
            const controlX = x1 + (x2 - x1) * 0.5;
            const controlY1 = y1;
            const controlY2 = y2;
            path.setAttribute('d', `M${x1} ${y1} C${controlX} ${controlY1}, ${controlX} ${controlY2}, ${x2} ${y2}`);
            path.setAttribute('class', 'connection');
            connectionsSvg.appendChild(path);
        });
    }

    // Dragging / Panning
    function startDrag(e, el) {
        draggingNode = el;
        draggingNode.classList.add('dragging');
        const rect = draggingNode.getBoundingClientRect();
        panState.offsetX = e.clientX - rect.left;
        panState.offsetY = e.clientY - rect.top;
        e.preventDefault();
        document.addEventListener('mousemove', handleDrag);
        document.addEventListener('mouseup', endDrag);
    }

    function handleDrag(e) {
        if (draggingNode) {
            draggingNode.style.left = (e.clientX - panState.offsetX) + 'px';
            draggingNode.style.top = (e.clientY - panState.offsetY) + 'px';
            drawConnections();
        } else if (panState.isPanning) {
            const dx = e.clientX - panState.startX;
            const dy = e.clientY - panState.startY;

            nodes.forEach(n => {
                n.el.style.left = (parseFloat(n.el.style.left) + dx) + 'px';
                n.el.style.top = (parseFloat(n.el.style.top) + dy) + 'px';
            });

            panState.startX = e.clientX;
            panState.startY = e.clientY;
            drawConnections();
        }
    }

    function endDrag() {
        if (draggingNode) {
            draggingNode.classList.remove('dragging');
            captureState();
        }
        draggingNode = null;
        document.removeEventListener('mousemove', handleDrag);
        document.removeEventListener('mouseup', endDrag);
    }

    // Panning (Canvas Movement)
    canvas.addEventListener('mousedown', (e) => {
        if (e.target === canvas || e.target === connectionsSvg) {
            panState.isPanning = true;
            panState.startX = e.clientX;
            panState.startY = e.clientY;
            canvas.classList.add('grabbing');
            // Start listening for movement
            document.addEventListener('mousemove', handleDrag);
            document.addEventListener('mouseup', endPan);
        }
    });

    function endPan() {
        if (panState.isPanning) {
            captureState();
        }
        panState.isPanning = false;
        canvas.classList.remove('grabbing');
        document.removeEventListener('mousemove', handleDrag);
        document.removeEventListener('mouseup', endPan);
    }

    // Resizing
    function startResize(e, el) {
        resizingNode = el;
        resizeStart = {
            x: e.clientX,
            y: e.clientY,
            width: el.offsetWidth,
            height: el.offsetHeight
        };
        document.addEventListener('mousemove', handleResize);
        document.addEventListener('mouseup', endResize);
    }

    function handleResize(e) {
        if (!resizingNode) return;
        const dx = e.clientX - resizeStart.x;
        const dy = e.clientY - resizeStart.y;

        // Apply new dimensions, clamping at minimum size
        resizingNode.style.width = Math.max(80, resizeStart.width + dx) + 'px';
        resizingNode.style.height = Math.max(40, resizeStart.height + dy) + 'px';

        // Ensure text is multiline if node is manually resized
        const textEl = resizingNode.querySelector('.node-text');
        if (textEl.style.whiteSpace !== 'normal') {
            textEl.style.whiteSpace = 'normal';
        }

        drawConnections();
    }

    function endResize() {
        if (resizingNode) {
            captureState();
        }
        resizingNode = null;
        document.removeEventListener('mousemove', handleResize);
        document.removeEventListener('mouseup', endResize);
    }

    // Double-click to create new root node
    canvas.addEventListener('dblclick', (e) => {
        if (e.target === canvas || e.target === connectionsSvg) {
            createNode('New Idea', e.clientX - 60, e.clientY - 30, null);
        }
    });

    // --- Save/Load & Gallery ---

    // Saves current map state to Local Storage
    async function saveMap() {
        const title = mapTitleInput.value.trim();
        if (!title && currentMapIndex === null) {
            await saveAsMap();
            return;
        }

        const currentMap = {
            title: title || originalTitle || 'Untitled Map',
            nodes: nodes.map(n => ({
                id: n.id,
                parentId: n.parentId,
                text: n.el.querySelector('.node-text').textContent,
                x: parseFloat(n.el.style.left),
                y: parseFloat(n.el.style.top),
                width: n.el.offsetWidth,
                height: n.el.offsetHeight
            })),
            timestamp: Date.now()
        };

        const galleryData = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '[]');

        if (currentMapIndex !== null) {
            // Update existing map
            galleryData[currentMapIndex] = currentMap;
        } else {
            // New map - treat as Save As
            await saveAsMap();
            return;
        }

        localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(galleryData));
        originalTitle = currentMap.title;
        mapTitleInput.value = originalTitle;
        renderGallery();
        await showAlert(`Map saved: ${originalTitle}`);
    }

    // Prompts user for a title and saves a new copy
    async function saveAsMap() {
        let newTitle = await showPrompt("Enter a title for the new map:", mapTitleInput.value.trim() || 'Untitled Map');

        if (newTitle === null || newTitle.trim() === '') {
            await showAlert("Save operation cancelled.");
            return;
        }
        newTitle = newTitle.trim();

        const currentMap = {
            title: newTitle,
            nodes: nodes.map(n => ({
                id: n.id,
                parentId: n.parentId,
                text: n.el.querySelector('.node-text').textContent,
                x: parseFloat(n.el.style.left),
                y: parseFloat(n.el.style.top),
                width: n.el.offsetWidth,
                height: n.el.offsetHeight
            })),
            timestamp: Date.now()
        };

        const galleryData = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '[]');
        galleryData.push(currentMap);
        localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(galleryData));

        // Set this new map as the current one
        currentMapIndex = galleryData.length - 1;
        originalTitle = newTitle;
        mapTitleInput.value = newTitle;

        renderGallery();
        await showAlert(`Map saved as: ${newTitle}`);
    }

    // Loads a map from the gallery by index
    function loadMap(index) {
        const galleryData = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '[]');
        const mapData = galleryData[index];
        if (!mapData) return;

        // Reset history and canvas
        history = [];
        historyIndex = -1;
        clearCanvas();

        // Restore nodes
        mapData.nodes.forEach(n => createNode(n.text, n.x, n.y, n.parentId, n.id, n.width, n.height, true));

        // Set title and context
        mapTitleInput.value = mapData.title;
        originalTitle = mapData.title;
        currentMapIndex = index;

        // Capture initial state for undo/redo
        captureState();
        drawConnections();
        gallery.style.display = 'none';
    }

    // Deletes a map from the gallery by index
    async function deleteMap(index) {
        let galleryData = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '[]');
        const titleToDelete = galleryData[index].title;

        galleryData.splice(index, 1);
        localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(galleryData));

        // Update current map index if the deleted map was the current one or before it
        if (currentMapIndex === index) {
            newMap(); // Start a new, unsaved map
        } else if (currentMapIndex > index) {
            currentMapIndex--;
        }

        renderGallery();
        await showAlert(`Map deleted: ${titleToDelete}`);
    }

    // Renders the gallery content
    function renderGallery() {
        galleryList.innerHTML = '';
        const galleryData = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '[]');

        if (galleryData.length === 0) {
            galleryList.innerHTML = `<div style="padding: 10px; font-style: italic; color: var(--text-muted); font-size: 13px;">No saved maps yet.</div>`;
            return;
        }

        galleryData.forEach((map, index) => {
            const itemEl = document.createElement('div');
            itemEl.className = 'gallery-item';
            itemEl.onclick = () => loadMap(index);

            // Link Icon Button
            const linkBtn = document.createElement('button');
            linkBtn.className = 'item-action-btn';
            linkBtn.innerHTML = '<i data-lucide="link" style="width:16px; height:16px;"></i>';
            linkBtn.title = 'Get Embed Link';
            linkBtn.onclick = (e) => {
                e.stopPropagation();
                const embedLink = `${APP_BASE_URL}?mapIndex=${index}`;
                showLink("Copy this URL to share or embed this map:", embedLink);
            };

            const infoEl = document.createElement('div');
            infoEl.className = 'item-info';
            infoEl.innerHTML = `
                <div class="item-title">${map.title}</div>
                <div class="item-date">${new Date(map.timestamp).toLocaleDateString()} ${new Date(map.timestamp).toLocaleTimeString()}</div>
            `;

            // Delete Icon Button
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'item-action-btn delete';
            deleteBtn.innerHTML = '<i data-lucide="x" style="width:16px; height:16px;"></i>';
            deleteBtn.title = 'Delete Map';
            deleteBtn.onclick = (e) => {
                e.stopPropagation();
                deleteMap(index);
            };

            itemEl.appendChild(linkBtn);
            itemEl.appendChild(infoEl);
            itemEl.appendChild(deleteBtn);
            galleryList.appendChild(itemEl);
        });
        lucide.createIcons();
    }

    // Starts a completely new, unsaved map
    function newMap() {
        history = [];
        historyIndex = -1;
        currentMapIndex = null;
        originalTitle = '';
        mapTitleInput.value = '';
        clearCanvas();

        // Create initial root node
        const centerX = window.innerWidth / 2 - 60;
        const centerY = window.innerHeight / 2 - 30;
        createNode('New Mindmap', centerX, centerY, null, null, null, null, true);

        // Capture initial state
        captureState();
    }

    // --- Initialization and Event Wiring ---

    document.getElementById('save-btn').onclick = saveMap;
    document.getElementById('save-as-btn').onclick = saveAsMap;
    document.getElementById('new-btn').onclick = newMap;
    document.getElementById('gallery-btn').onclick = () => {
        gallery.style.display = gallery.style.display === 'none' ? 'block' : 'none';
        if (gallery.style.display === 'block') renderGallery();
    };

    document.getElementById('undo-btn').onclick = () => {
        if (historyIndex > 0) {
            restoreState(history[--historyIndex]);
        }
    };
    document.getElementById('redo-btn').onclick = () => {
        if (historyIndex < history.length - 1) {
            restoreState(history[++historyIndex]);
        }
    };

    // Keyboard Shortcuts (Undo/Redo)
    document.addEventListener('keydown', (e) => {
        if (!e.target.matches('input, [contenteditable="true"]')) {
            if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                document.getElementById('undo-btn').click();
            } else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
                e.preventDefault();
                document.getElementById('redo-btn').click();
            }
        }
    });
    const saveDropdownBtn = document.getElementById('save-dropdown-btn');
const saveDropdownMenu = document.getElementById('save-dropdown-menu');
const saveAsMenuItem = document.getElementById('save-as-menu-item');
const saveMainBtn = document.getElementById('save-main-btn');

saveMainBtn.onclick = saveMap;
saveAsMenuItem.onclick = saveAsMap;

saveDropdownBtn.onclick = (e) => {
    e.stopPropagation();
    saveDropdownMenu.style.display =
        saveDropdownMenu.style.display === 'flex' ? 'none' : 'flex';
};

// Close dropdown when clicking outside
document.addEventListener('click', () => {
    saveDropdownMenu.style.display = 'none';
});

    // Map title input change also captures state
    mapTitleInput.addEventListener('blur', captureState);

    // Initial load logic
    function initialize() {
        const urlParams = new URLSearchParams(window.location.search);
        const mapIndexParam = urlParams.get('mapIndex');

        renderGallery(); // Populate gallery initially

        if (mapIndexParam !== null) {
            const index = parseInt(mapIndexParam);
            const galleryData = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '[]');
            if (index >= 0 && index < galleryData.length) {
                loadMap(index);
            } else {
                newMap();
            }
        } else {
            newMap();
        }

        // Initialize Lucide icons on load (necessary for all buttons)
        lucide.createIcons();
    }

    window.onload = initialize;

</script>
</body>
</html>
